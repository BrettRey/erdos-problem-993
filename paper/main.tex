% !TEX TS-program = xelatex
\documentclass[12pt,oneside]{article}
\input{../../../.house-style/preamble.tex}

% ============================
% Additional packages
% ============================
\usepackage{amsthm}

% Theorem environments
\newtheorem{conjecture}{Conjecture}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

% ============================
% Notation macros
% ============================
\newcommand{\indpoly}{I(T;\,x)}           % independence polynomial
\newcommand{\ik}{i_k(T)}                  % coefficient
\newcommand{\nm}{\mathrm{nm}}             % near-miss ratio
\newcommand{\broom}{\mathrm{B}}           % broom notation

% ============================
% Metadata
% ============================
\title{Unimodality of independence polynomials of trees:\\
  computational verification and broom asymptotics}
\author{Brett Reynolds\,\orcidlink{0000-0003-2407-9448}}
\date{}

\begin{document}
\maketitle

\begin{abstract}
\citet{alavi1987} conjectured that the independence polynomial of every tree is unimodal.
I report three computational results bearing on this conjecture.
First, I verify it exhaustively for all 447\,672\,596 non-isomorphic trees on at most 26 vertices, extending the previously published bound of $n \le 25$.
At $n = 26$ I confirm exactly two log-concavity failures and no unimodality failures, with every tree's coefficient sequence comfortably unimodal.
Second, I test 145\,362 trees from five structured families (subdivided stars, caterpillars, spiders, brooms, and random perturbations) at sizes up to $n = 500$, finding zero unimodality violations.
Third, I identify broom trees as the family approaching the unimodality boundary most closely and establish an empirical scaling law: for the broom $\broom(p,s)$, the near-miss ratio satisfies $\nm(s) = 1 - C/s + O(1/s^2)$ with $C \approx 4.12$, so that the margin of unimodality shrinks as $O(1/s)$ but never vanishes.
\end{abstract}

\section{Introduction}\label{sec:intro}

An \emph{independent set} in a graph $G$ is a set of vertices no two of which are adjacent.
Write $i_k(G)$ for the number of independent sets of size~$k$ in~$G$, and let $\alpha(G)$ denote the independence number (the maximum size of an independent set).
The \emph{independence polynomial} of~$G$ is
\[
  I(G;\, x) \;=\; \sum_{k=0}^{\alpha(G)} i_k(G)\, x^k,
\]
with the convention $i_0(G) = 1$.

\begin{conjecture}[\citealp{alavi1987}]\label{conj:main}
  For every tree~$T$, the sequence $i_0(T), i_1(T), \dotsc, i_{\alpha(T)}(T)$ is unimodal.
\end{conjecture}

\citet{alavi1987} showed that the independence sequence of a general graph can realize any prescribed shape, but conjectured that trees are constrained enough to force unimodality.
The conjecture naturally suggested a stronger form: that the sequence should be \emph{log-concave}, meaning $i_k^2 \ge i_{k-1}\, i_{k+1}$ for all~$k$.
This stronger property held for all trees tested computationally until $n = 26$, when \citet{kadrawi2023} found exactly two trees whose independence sequences are unimodal but not log-concave.
\citet{galvin2025} subsequently constructed infinite families of trees (subdivided stars) with log-concavity failures arbitrarily far from the ends of the sequence.
\citet{ramos2025} used machine learning (PatternBoost) to find tens of thousands of log-concavity failures up to $n = 101$, but no unimodality failure.

On the positive side, unimodality has been proved for several tree families: paths, centipedes, regular caterpillars, and Fibonacci trees (which are real-rooted, hence log-concave), as well as well-covered spiders and certain restricted caterpillars.
\citet{levit2006} showed that $i_k(T)$ is strictly decreasing for $k \ge \lceil (2\alpha - 1)/3 \rceil$, so any unimodality violation must occur in roughly the first two-thirds of the sequence.
\citet{heilman2025} proved that for a uniformly random labelled tree on $n$ vertices, the first $\approx 46.8\%$ of the independence sequence is increasing with high probability; combined with the Levit--Mandrescu tail bound, roughly 85\% of the sequence is known to behave as expected almost surely.

The best previously published exhaustive verification is $n \le 25$ (A.~Radcliffe, personal communication, cited in several papers).
I extend this to $n \le 26$, test structured families up to $n = 500$, and identify brooms as the trees closest to violating unimodality.

My contributions:
\begin{enumerate}
  \item Exhaustive verification of Conjecture~\ref{conj:main} for all trees on $n \le 26$ vertices (Section~\ref{sec:exhaustive}).
  \item Targeted verification across five tree families at sizes up to $n = 500$ (Section~\ref{sec:targeted}).
  \item An empirical asymptotic analysis showing that broom trees approach the unimodality boundary at rate $O(1/s)$ (Section~\ref{sec:broom}).
\end{enumerate}


\section{Definitions and method}\label{sec:method}

\begin{definition}
  A finite sequence $(a_0, a_1, \dotsc, a_m)$ of positive reals is \emph{unimodal} if there exists an index~$p$ such that $a_0 \le a_1 \le \dotsb \le a_p \ge a_{p+1} \ge \dotsb \ge a_m$.
  It is \emph{log-concave} if $a_k^2 \ge a_{k-1}\, a_{k+1}$ for all $1 \le k \le m-1$.
\end{definition}

Log-concavity (with positive terms) implies unimodality, but not conversely.

\paragraph*{Near-miss ratio.}
To quantify how close a tree comes to violating unimodality, I define the \emph{near-miss ratio}.
Let $j_0$ be the first index where $i_{j_0} > i_{j_0+1}$ (the first strict descent).
The near-miss ratio is
\[
  \nm(T) \;=\; \max_{j > j_0} \frac{i_{j+1}(T)}{i_j(T)}.
\]
If $\nm(T) > 1$, the sequence rises after descending, violating unimodality.
A value near 1 indicates that the tree nearly violates it.

\paragraph*{Tree DP.}
The computation of $I(T;\, x)$ proceeds by rooting $T$ at an arbitrary vertex and performing a bottom-up traversal.
For each vertex~$v$, two polynomials are maintained: $d_v^{(0)}(x)$ counts independent sets in the subtree of~$v$ that exclude~$v$; $d_v^{(1)}(x)$ counts those that include~$v$.
The recurrences are
\begin{align}
  d_v^{(0)} &= \prod_{c \,\in\, \mathrm{children}(v)} \bigl(d_c^{(0)} + d_c^{(1)}\bigr), \label{eq:dp0}\\
  d_v^{(1)} &= x \cdot \prod_{c \,\in\, \mathrm{children}(v)} d_c^{(0)}, \label{eq:dp1}
\end{align}
and $I(T;\, x) = d_r^{(0)} + d_r^{(1)}$ for the root~$r$.
The total time per tree is $O(n^2)$, dominated by polynomial multiplications via naive convolution.

\paragraph*{Computational setup.}
Trees are enumerated with \texttt{nauty/geng} \citep{mckay2014}, which generates all non-isomorphic connected graphs on $n$ vertices with exactly $n - 1$ edges.
Computation is parallelized by passing \texttt{geng}'s \texttt{res/mod} partitioning to eight workers via Python's \texttt{multiprocessing}.
Polynomial arithmetic uses \texttt{numpy.convolve} when coefficients fit in 64-bit integers, with automatic fallback to pure Python big-integer arithmetic for larger values (relevant at $n \gtrsim 90$).
Log-concavity is checked using integer arithmetic ($i_k^2$ vs.\ $i_{k-1}\, i_{k+1}$), avoiding floating-point error.


\section{Exhaustive verification through $n = 26$}\label{sec:exhaustive}

Table~\ref{tab:exhaustive} shows the verification results.
Every tree count matches OEIS A000055 \citep{oeis-a000055}.
No unimodality violation was found at any~$n$.

\begin{table}[ht]
  \centering
  \caption{Exhaustive verification of unimodality for trees on $n$ vertices.  Times are for an Apple Silicon Mac with 8 parallel workers ($n \ge 21$) or a single process ($n \le 20$).}
  \label{tab:exhaustive}
  \begin{tabular}{r r r}
    \toprule
    $n$ & Trees & Time \\
    \midrule
    1--15 & \liningnums{13\,188} & ${<}\,1$\,s \\
    16 & \liningnums{19\,320} & 1\,s \\
    17 & \liningnums{48\,629} & 3\,s \\
    18 & \liningnums{123\,867} & 9\,s \\
    19 & \liningnums{317\,955} & 23\,s \\
    20 & \liningnums{823\,065} & 68\,s \\
    21 & \liningnums{2\,144\,505} & 55\,s \\
    22 & \liningnums{5\,623\,756} & 1\,m\,44\,s \\
    23 & \liningnums{14\,828\,074} & 4\,m\,41\,s \\
    24 & \liningnums{39\,299\,897} & 12\,m\,5\,s \\
    25 & \liningnums{104\,636\,890} & 38\,m\,33\,s \\
    26 & \liningnums{279\,793\,450} & 4\,h\,51\,m \\
    \midrule
    Total & \liningnums{447\,672\,596} & \\
    \bottomrule
  \end{tabular}
\end{table}

The case $n = 26$ is particularly interesting because it is the first~$n$ at which log-concavity fails \citep{kadrawi2023}.
A re-analysis of all 279\,793\,450 trees at $n = 26$ found:
\begin{itemize}
  \item Exactly 2 log-concavity failures (consistent with \citealp{kadrawi2023}), both at index $k = 13$.
    The worst log-concavity ratio is $i_{12}\, i_{14} / i_{13}^2 = 1.145$, exceeding the threshold of~1.
  \item The best (highest) near-miss ratio at $n = 26$ is $\nm = 0.845$, far below the violation threshold of~1.
\end{itemize}

In other words, even at the first~$n$ where the stronger log-concavity property breaks, unimodality holds with a comfortable margin: the tightest near-miss is only 84.5\% of the way to a violation.


\section{Targeted search on structured families}\label{sec:targeted}

Beyond exhaustive enumeration, I tested 145\,362 trees from five families chosen for their proximity to the unimodality boundary.
Results appear in Table~\ref{tab:targeted}.

\begin{table}[ht]
  \centering
  \caption{Targeted verification on structured tree families ($n$ up to 500).
    LC = log-concavity.  Best~nm is the highest near-miss ratio observed in the family.}
  \label{tab:targeted}
  \begin{tabular}{l r r l}
    \toprule
    Family & Trees & LC failures & Best nm \\
    \midrule
    Galvin SST $T_{m,t,1}$     & \liningnums{571}     & \liningnums{108} & 0.936 \\
    Generalized SST $T_{m,t,d}$ & \liningnums{680}    & \liningnums{268} & 0.981 \\
    Caterpillars                & \liningnums{5\,196}  & 0 & -- \\
    Spiders and brooms          & \liningnums{133\,915}& 0 & 0.992 \\
    Random (Ramos--Sun style)   & \liningnums{5\,000}  & \liningnums{2} & 0.804 \\
    \midrule
    Total                       & \liningnums{145\,362}& \liningnums{378} &  \\
    \bottomrule
  \end{tabular}
\end{table}

No unimodality violation was found in any family.
Three patterns stand out:
\begin{itemize}
  \item \textbf{Subdivided stars dominate log-concavity failures} (376 of 378), consistent with \citet{galvin2025}, but their near-miss ratios stay well below~1.
  \item \textbf{Caterpillars are perfectly log-concave} through $n = 500$, with zero failures.
  \item \textbf{Brooms produce the highest near-miss ratios} ($\nm = 0.992$ at $n = 500$), surpassing all SST variants despite having no log-concavity failures.
\end{itemize}

A \emph{broom} $\broom(p, s)$ consists of a path on $p$ vertices with a star of $s$ leaves attached at one end; it has $n = p + s$ vertices and independence number $\alpha = \lfloor p/2 \rfloor + s$.
The broom $\broom(33, 467)$ at $n = 500$ achieves $\nm = 0.9917$, the highest observed anywhere in this study.
This makes brooms, not subdivided stars, the family closest to the unimodality boundary.


\section{Broom asymptotics}\label{sec:broom}

The targeted results raised a natural question: does the broom near-miss ratio converge to~1 as $s \to \infty$?
If so, the conjecture would be true for brooms but only barely, with the margin vanishing in the limit.

I computed $\broom(13, s)$ for $s$ up to 20\,000 (trees with over 20\,000 vertices, independence polynomials with degrees in the tens of thousands).
Table~\ref{tab:broom} shows the results.

\begin{table}[ht]
  \centering
  \caption{Broom $\broom(13, s)$: convergence of the near-miss ratio.
    The scaled gap $s \cdot (1 - \nm)$ stabilizes near $C \approx 4.12$.}
  \label{tab:broom}
  \begin{tabular}{r r l l l}
    \toprule
    $s$ & $n$ & $\nm$ & $1 - \nm$ & $s \cdot (1 - \nm)$ \\
    \midrule
    1\,000  & 1\,013  & 0.995\,911 & 0.004\,09 & 4.089 \\
    2\,000  & 2\,013  & 0.997\,947 & 0.002\,05 & 4.105 \\
    5\,000  & 5\,013  & 0.999\,177 & 0.000\,82 & 4.115 \\
    10\,000 & 10\,013 & 0.999\,588 & 0.000\,41 & 4.119 \\
    20\,000 & 20\,013 & 0.999\,794 & 0.000\,21 & 4.120 \\
    \bottomrule
  \end{tabular}
\end{table}

The data fit the scaling law
\begin{equation}\label{eq:scaling}
  \nm(s) \;=\; 1 - \frac{C}{s} + O(1/s^2),
\end{equation}
with $C \approx 4.12$ for $p = 13$.
The same qualitative behaviour was observed (convergence of $s \cdot (1 - \nm)$ to a constant) for path lengths $p \in \{13, 22, 33, 42, 50\}$, with the constant~$C$ varying by path length.
In every case, $\nm < 1$ for all tested~$s$, so all brooms remain unimodal.

\begin{remark}
  The broom $\broom(p, s)$ has a closed-form independence polynomial derived from the path recurrence and star contribution, making it a natural candidate for analytic proof.
  Proving that $C(p) > 0$ for all $p$ would establish unimodality for the entire broom family and identify the exact rate at which the margin vanishes.
\end{remark}


\section{Discussion}\label{sec:discussion}

These results provide strong computational evidence for Conjecture~\ref{conj:main}.
Across 448 million exhaustively tested trees and 145 thousand structurally targeted trees, no unimodality violation was found.
The conjecture appears robust, but the broom asymptotic analysis reveals that it is also tight: the margin of unimodality can be made arbitrarily small.

The surprise is that brooms, not subdivided stars, are closest to the boundary.
Subdivided stars produce many log-concavity failures but stay well within the unimodality threshold.
Brooms remain log-concave yet push the near-miss ratio toward~1.
This suggests that the mechanisms behind log-concavity failure and near-unimodality violation are distinct.

Several directions remain:
\begin{itemize}
  \item An analytic proof of broom unimodality, exploiting the closed-form independence polynomial of broom trees.
  \item Extension of the exhaustive search to $n = 27$ (751 million trees). The current Python implementation would require roughly 12--15 hours on 8 cores; a compiled inner loop would reduce this substantially.
  \item Adaptation of PatternBoost \citep{ramos2025} to optimize for near-miss ratio rather than log-concavity failure, which might discover families even closer to the boundary.
\end{itemize}

All code, data, and reproduction scripts are available at \url{https://github.com/brettrey/erdos-993}.


\section*{Acknowledgements}

Computational exploration and code development were assisted by Claude Opus~4.6 (Anthropic).

\appendix

\section{Reproducibility}\label{app:repro}

\paragraph*{Hardware.}
All computations were run on an Apple M4 (arm64) with 32\,GB RAM, running macOS.

\paragraph*{Software versions.}
Python~3.14.2, NumPy~2.4.2, NetworkX~3.6.1, nauty/geng~2.9301 (32-bit).

\paragraph*{Reproduction commands.}
\begin{verbatim}
pip install networkx numpy
brew install nauty

# Unit tests (29 tests)
python3 -m unittest test_all.py -v

# Exhaustive search, n <= 20 (single process)
python3 search.py --max-n 20

# Exhaustive search, n <= 26 (8 workers, requires geng)
python3 search.py --max-n 26 --workers 8

# Exhaustive n=26 analysis (LC + near-miss metrics)
python3 analyze.py 26 --workers 8 --top-k 200

# Targeted family search (n up to 500)
python3 targeted.py --max-n 500 --random-count 5000

# Broom asymptotic study
python3 broom_asymptotic.py
\end{verbatim}

Random seeds are fixed (\texttt{random.Random(42)}) in \texttt{targeted.py} for caterpillar and Ramos--Sun families, ensuring deterministic reproduction.
Per-family breakdowns (counts, LC failures, best near-miss) are archived in \texttt{results/targeted\_families.json}.

\paragraph*{Data files.}
\begin{itemize}
  \item \texttt{results/analysis\_n26.json} -- Full n=26 re-analysis: 2 LC failures, top 200 near-misses with polynomials.
  \item \texttt{results/targeted\_n500.json} -- Top 500 near-misses from targeted search.
  \item \texttt{results/targeted\_families.json} -- Per-family summary (Table~\ref{tab:targeted}).
\end{itemize}


\section{Verification checklist}\label{app:verify}

\begin{enumerate}
  \item \textbf{Tree counts match OEIS A000055.}
    Every per-$n$ count reported by \texttt{search.py} was checked against A000055 \citep{oeis-a000055}.
    The search halts with an error if counts disagree.

  \item \textbf{Small-$n$ cross-check across backends.}
    For $n \le 18$, the independence polynomial was computed both via the geng pipeline and via NetworkX tree generation.
    Results were identical.

  \item \textbf{Known examples verified.}
    The two LC-failing trees at $n = 26$ from \citet{kadrawi2023} were independently reproduced: our search found exactly two LC failures, both at index $k = 13$, with LC ratios 1.145 and 1.030.

  \item \textbf{Integer arithmetic for log-concavity.}
    All LC checks use $i_{k-1}\, i_{k+1}$ vs.\ $i_k^2$ in exact integer arithmetic (Python arbitrary-precision integers), with no floating-point rounding.

  \item \textbf{Overflow guard for polynomial multiplication.}
    \texttt{numpy.convolve} is used only when the maximum product of coefficient sizes fits in 64-bit integers (threshold: $\max(\mathit{terms}) \cdot \max(a) \cdot \max(b) < 2^{62}$).
    Beyond this, multiplication falls back to pure Python big-integer arithmetic.
    The guard triggers for tree families at $n \gtrsim 90$.

  \item \textbf{Unit tests.}
    29 tests cover: independence polynomial correctness on small graphs (paths, stars, known examples), unimodality and LC checks, near-miss ratio computation, graph6 parsing, and tree generation.
\end{enumerate}

\newpage
\printbibliography

\end{document}
